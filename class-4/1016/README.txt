[1016] 제곱 ㄴㄴ 수 (https://www.acmicpc.net/problem/1016)

시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
2 초		512 MB		30374	4971	3350		19.635%

문제
----
어떤 수 X가 1보다 큰 제곱수로 나누어 떨어지지 않을 때, 제곱ㄴㄴ수라고 한다. 제곱수는 정수의 제곱이다. min과 max가 주어지면, min과 max를 포함한 사이에 제곱ㄴㄴ수가 몇 개 있는지 출력한다.

입력
----
첫째 줄에 두 정수 min과 max가 주어진다.

출력
----
첫째 줄에 [min,max]구간에 제곱ㄴㄴ수가 몇 개인지 출력한다.

제한
----
1 ≤ min ≤ 1,000,000,000,000
min ≤ max ≤ min + 1,000,000

풀이
----
min값이 최대 1조까지 가능하므로, 변수 min, max는 범위가 ±2,147,483,648인 int형(정수형, 4byte)으로 선언하면 안되고, 
범위가 ±9,223,372,036,854,775,808인 long long(정수형, 8byte)을 사용해야 한다.
p.s) c++에서 double(실수형, 8byte)은 배열의 인덱스에 사용할 수 없다. Java는 사용가능.

제곱ㄴㄴ수를 판별하기 위해 소수를 판별하는 방법들 중 하나인 "에라토스테네스의 체"를 변형하여 해결할 수 있다.

"에라토스테네스의 체"란, 소수 2부터 시작해서 자기자신을 제외한 자신의 배수들을 모두 지우고,  다시 2보다 큰 소수인 3부터 시작해서 위 방식을 반복함으로써 대량의 소수를 판별하는 방식이다.

즉, 이 문제를 풀기 위해서는 [min, max] 범위 내의 2의 제곱수인 4와 4의 배수들을 모두 지우고, 다시 3의 제곱수인 9와 9의 배수들을 모두 지우는 식으로 대량의 제곱ㄴㄴ수를 판별한다.

이를 구현하는 방식은 다음과 같다.
먼저, n = 2부터 시작해서 n의 제곱수가 max 이하이면 반복하는 while문을 만든다.
반복문 내부에 min을 n의 제곱수로 나눈 값을 cur에 저장하고, 이 값에 나머지가 존재하는 경우 cur값을 1 증가시켜준다. (∵ min > cur * n 이므로)
cur * n의 제곱수가 max 이하이면 반복하는 이중 while문을 만들고, 내부에 배열의 해당 값이 제곱수라는 표시를 하고, cur을 1 증가시키고 이 과정을 반복한다.
이중 while문을 탈출하면, n을 1 증가시키고 위 과정을 반복한다.