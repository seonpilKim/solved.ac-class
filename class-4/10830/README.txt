[10830] 행렬 제곱 (https://www.acmicpc.net/problem/10830)

시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
1 초		256 MB		9497	3251	2634		34.239%

문제
----
크기가 N*N인 행렬 A가 주어진다. 이때, A의 B제곱을 구하는 프로그램을 작성하시오. 수가 매우 커질 수 있으니, A^B의 각 원소를 1,000으로 나눈 나머지를 출력한다.

입력
----
첫째 줄에 행렬의 크기 N과 B가 주어진다. (2 ≤ N ≤  5, 1 ≤ B ≤ 100,000,000,000)

둘째 줄부터 N개의 줄에 행렬의 각 원소가 주어진다. 행렬의 각 원소는 1,000보다 작거나 같은 자연수 또는 0이다.

출력
----
첫째 줄부터 N개의 줄에 걸쳐 행렬 A를 B제곱한 결과를 출력한다.

풀이
----
*Key point
 1. 행렬 간 곱셈 구현
 2. 시간초과 해결방법 찾기


 - 행렬 간 곱셈 구현
행렬 간 곱셈 구현은, 행렬 간 곱셈을 할 때 각 행렬 elment의 index 변화를 관찰하면서 규칙성을 발견하는 것에서부터 시작한다.

2x2 행렬 간 곱셈을 예로 들면,
[0][0] x [0][0] + [0][1] x [1][0] | [0][0] x [0][1] + [0][1] x [1][1]
[1][0] x [0][0] + [1][1] x [1][0] | [1][0] x [0][1] + [1][1] x [1][1]
이렇게 나타낼 수 있다.

일반화해서 나타내보면,
1) int k
1번째 행렬은 1행부터 n행까지 돌면서 1열에서 시작해 n열까지 1칸씩 이동하며 곱하고,
2번째 행렬은 1열부터 n열까지 돌면서 1행에서 시작해 n행까지 1칸씩 이동하며 곱한다.
2) int j
그리고 곱셈 결과 행렬의 첫 번째 element값이 결정되면, 다음 element값을 결정하기 위해 2번째 행렬의 시작 열을 1 증가시켜 위의 곱셈과정을 반복한다.
즉, 한 element 곱셈이 끝나면 2번째 행렬의 "열"부터 이동하면서 다음 element 곱셈을 수행한다.
3) int i
2번째 행렬의 n열까지 곱셈이 끝나면, 다음 곱셈부터는 1번째 행렬의 2행으로 이동하고, 2번째 행렬의 1열부터 위 곱셈과정을 반복한다.

먼저 반복하는 순서대로 반복문의 안쪽에 구현시키면 된다.
최종적으로 Result[i][j] += A[i][k] * B[k][j] 으로 나타낼 수 있다. (i가 가장 바깥쪽, k가 가장 안쪽)



 - 시간초과 해결방법 찾기
만약 B의 최대값인 1조번 A를 곱하면 무려 1000초가 넘는 시간이 소요되므로 TLE이다.
그러므로 이 연산횟수를 줄이는 것에 초점을 두고 방법을 떠올려야 한다.
반복되는 연산을 수행할 때, 거듭제곱 방식으로 수행한다면 O(log N)까지 수행시간을 빠르게 만들 수 있다.

구현방법은 다음과 같다.
총 곱셈횟수를 r이라 했을 때, 행렬 A를 제곱한 결과를 A에 저장하고, r에 r을 2로 나눈 값을 저장한다.
이 과정을 r이 0이될 때까지 반복하며, r이 홀수인 경우는 A에 Res라는 단위행렬을 곱한 결과를 Res에 저장하는 과정도 추가적으로 수행하며 최종적으로 Res를 반환한다.
(r이 처음부터 끝까지 짝수를 유지하는 경우에도 결국 1이될 때, 홀수가 되므로 결과출력에는 문제되지 않는다.)

예를 들어, 총 A의 15승을 구한다고 해보자.
15 -> 7 -> 3 -> 1
Res : 1 -> 3 -> 7 -> 15
A : 2 -> 4 -> 8
만약 A의 16승이라면,
16 -> 8 -> 4 -> 2 -> 1 으로 곱셈 과정이 한 번 더 추가되는 것을 알 수 있다. (2의 거듭제곱이므로 당연하다)
이렇듯, Res에서 r이 홀수인 경우 값을 따로 저장 및 관리함으로써 거듭제곱 알고리즘을 완벽하게 구현 해낼 수 있다.